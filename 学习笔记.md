dotnet CSharp 学习笔记
解决方案 Solution
项目 Project
空的 empty
本地主机 localhost
默认的 default
调用 Invoke
Explorer 浏览器，管理器,探险家
指针丢失 loss of pointer
order 命令
args	参数
invoke	调用
handler	处理程序
customer	客户
value	价值
bill	账单
large	大
reataurant	餐馆
vehicle 车辆，工具
access	使用，进入，机会。 接近
Collections 收集 
array 数组

public 公有的
protected	受保护的
internal	内部的
private 私有的 （只在类体里面） 默认是 private 

事件顺序
arg游戏
调用
处理程序
客户
价值
比尔
大
餐馆在哪
1、查看.NET Core 版本
	命令行： > dotnet --version
2、创建一个新的命令行程序
	命令行：>dotnet new console --name HelloCSharp
	
3.在记事本写程序。
	>cd HelloCSharp  
	>dotnet restore  实用.net 恢复
	使用记事本 编辑
	>dotnet build  实用.net 编译
	>dotnet run  运行


在路径条件下 输入CMD ，可以将命令行 运行到对应目录
缩写 按下TAB键，自动填写。
可以使用 visual studio code  ,安装 C#插件。
 
见识C#编写的各类应用程序 
 Console  控制台
 WPF (Windows Presentation Foundation) * 
 Windows Forms (Old)
 ASP.NET Web Forms (Old)
 Asp.NET MVC (Model-Vies-Controller)*
 WCF (Windows Communication Foundation)*
 Windows Store Application*
 Windows Phone Application*
 Cloud (Windows Azure)
 WF (Workflow Foundation)
 
 精通机器人控制基础
 熟练使用经典控制理论
 数学功底良好
 熟练使用C/C++编程（Ubuntu下）
  SLAM 算法学习经验
 
 
 events 事件
 方法
 
 003课程 初识类和命名空间
 类（class） 构成程序的主题
 名称空间（namespace） 以树型结构组织类（和其他类型）
 类库（Assmbly），实用名称空间的物理基础
 
 HELP  
 System 命名空间，名称空间（）,目的是为了避免类引用的冲突。
 权限命名：System.Console.**  如果有冲突，需要用权限命名方式。
* 查询某个类（console）是属于哪个名称空间？
	1、通过文档 help进查询； console class ;
	2、小技巧：红色波浪线，下面蓝色小方块，自动标注； 快捷键 crtl + “.” 回车
 
 类库的引用 
	-类库应用是使用名称空间的物理基础
	-DLL引用（黑盒引用，无源代码）
	-项目引用（白盒引用，有源代码） 
  
  //entity framework 引用 导入程序包
  //root cause!
  
  
 004 类,对象,类成员简介
 类（class）是现实世界事物的模型。 （符合唯物主义辩证法）
	*类是对现实世界事物进行抽象（建模）所得到的结果
		-事物包括“物质”（实体）与“运动”（逻辑）
		-建模是一个去伪存真、由表及里的过程
	
类（class）与对象(instance)的关系
*对象也叫实例，是类进过“实例化”后得到的内存中的实体
	*Formally "instance" is synonymous with "object" ————对象和实例是一回事
	*"飞机"与“一架飞机”有何区别？天上有（一架）飞机————必须是实例飞，概念是不能飞的
	*有些类是不能实例化的，比如“数学”（Math class），我们不能说“一个数学”
*依照类，我们可以创建对象（实例），这就是“实例化”
	*现实世界中常称“对象”，程序世界中常称“实例”，
	*二者并无太大区别，常常混用，初学者不必迷惑
*使用new操作符创建类的实例  eq： （new Forms()）.showdialog；   //new  操作符家一个 表单（），给表单实例化
*引用变量与实例的关系  Form myForm
	*孩子（引用变量）与气球（实例）
	*气球不一定有孩子牵着
	*多个孩子可以使用各自的绳子牵着同一个气球，也可以都通过一根绳子牵着气球
	使用引用变量引用这个实例之后，可以多次访问这个实例； 
	
类的三大成员
*属性（Property）
	存储数据，方便记忆；结合起来表示类或对象当前的状态，
*方法（Method）
	有C语言中的函数（function）进化而来的，表示类或对象“能做什么”
	工作中90%的时间是在于方法打交道，因为它是“真的做事”、“构成逻辑”的成员
*事件（Event）
	类或对象通知其他类或对象的机制，为C#所特有（Java通过其他办法实现这个机制）
	善用事件机制非常重要！！
*使用MSDN文档	
	
程序，就是算法+数据，用算法加工数据。
	
3个例子：
	MethodSample （以方法为侧重点）
	EventSample 电子时钟 （以事件为侧重点）：	事件处理器  两次 “tab”
	
静态成员与实例成员
*静态（Static） 成员哎语义上表示它是“类的成员”
*实例（非静态）成员在语义表示它是“对象的成员”
*绑定（Binding）指的是编译器如果把一个成员与类或对象关联起来
	*不可小觑的“.”操作符--成员访问
	
005 基本元素、初识类型、变量和方法
*构成c#语言的基本元素
	关键字（Keyword）
	操作符（Operator）
	标识符（Identifier）
	标点符号
	文字（字面值）
	注释与空白

*初识类型（Type）
	亦称数据类型（Data Type）
*变量是存放数据的地方，简称“数据”
	-变量的声明
	-变量的使用
*方法（旧称函数）是处理数据的逻辑，又称“算法”
	-方法的声明
	-方法的调用
*程序 = 数据 +算法
	-有了变量和方法，就可以写有意义的程序了
***递归方法	
	
006，详解类型、变量和方法
*什么是类型（Type)
*类型在C#语言中的作用
*C#语言的类型系统
*变量、对象与内存

什么是类型（Type）
*又名数据类型（Data Type）
	-性质相同的值得集合
	-是数据在内存中存储时的“型号”
	-小内存容纳大尺寸数据会丢失精准度、发生错误
	-大内存容纳小尺寸数据会导致浪费
	-编程语言的数据类型与数据的数据类型不完成相同
*强类型语言与弱类型语言的比较
	-C语言实例： if条件
	-JavaScript示例：动态类型
	-c#语言对弱类型/动态类型的模仿
	
	foreach 语句用于循环访问集合
类型在C#语言中的作用
*一个c#类型中所包含的信息有：
	-存储此类型变量所需的内存空间大小
	-此类型的值可以表示的最大/最小值范围
	-此类型所包含的成员（如方法/属性/事件等）
	-此类型由何基类派生而来
	-程序运行的时候，此类型的变量在分配在内存的什么位置
		--stack简介  栈 堆栈（Stack）代表了一个后进先出的对象集合，（先进后出原则）。
		--Stack overflow
		--Heap简介	堆 （先进先 出原则）。
		--使用Performance Monitor 查看进程的堆内存使用量
		--关于内存泄漏
	-此类型所允许的操作（运算）

C#语言的类型系统
*C#的五大数据类型
	-类（class）：如 Window,Form,Console，String
	-结构体（Structures）：如Int32,Int64,Single，Double
	-枚举（Enumerations）:	如HorizontalAlignment,Visibility
	-接口（Interfaces）
	-委托（Delegates）
*C#类型的派生谱系
	Object -引用类型(Reference Type)	--类  /--接口/ 委托
		-值类型(Value Type)	--结构体 --枚举
	
变量、对象与内存
*什么是变量
	--表面上来看，变量的用途是存储数据
	--实际上，变量表示了存储位置，并且每个变量都有一个类型，以决定什么样的值能够存入变量
	--变量一共有7种
		--静态变量，实例变量（成员变量、字段），数组元素，值参数，引用参数，输出参数，局部变量
	--狭义的变量指局部变量，因为其他种类的变量都有自己的约定名称
		--简单地讲，局部变量就是方法体（函数体）里声明的变量
	--变量的声明
		--有效的修饰符组合 opt类型 变量名 初始化器 opt   int a =0;
		
*值类型的变量
	--以byte/sbtye/short/ushort 为例
	--值类型没有实力，所谓的“实例”与变量合而为一
*应用类型的变量与实例
	--引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址
*变量的默认值
*常量（值不可改变的变量）
*装箱与拆箱（Boxing&Unboxing） 装箱，栈的值 放到堆上面；拆箱：将堆上面的数据，放到栈上面
	
WIN+"R" perfmon  打开性能监视器，监控内存
 	
008 、方法的定义、调用与调试
方法的由来
*方法（method）的前身是C/C++语言的函数（function）
	--方法是面向对象范畴的概念，在非面向对象语言中任然称为函数
	--使用C/C++语言做对比
	当函数以类的成员出现的时候，就成了方法。方法也称为成员函数。
*永远都是类（或结构体）的成员
	--C#语言中函数不可能独立于类（或结构体）之外
	--只有作为类（结构体）的成员时才被称为方法
	--C++中是可以的，称为“全局函数”
*是类（或结构体）最基本的成员之一
	--最基本的成员只有两个----字段与方法（成员变量与成员方法），本质还是数据+算法
	--方法表示类（或结构体）“能做什么事情”
*为什么需要方法和函数
	--目的1：影藏复杂的逻辑
	--目的2：服用（reuse,重用）
	--实例：计算元面积、圆柱体积、圆锥体积
	
方法的声明和调用
*声明方法的语法详解
	--参见C#语言文档（声明/定义不分家）
	--Parameter全称为“formal parameter”   perameter 范围；决定因素；范围  
		形式上的参数，简称“形参”
	--Parameter是一种变量
*为方的命名规范
	--大小写规范  ，全部首大写
	--需要以动词或者动词短语作为名字
*重温静态（static）方法和实例方法
*调用方法		
	*Argument中文C#文档的官方译法为“实际参数”，简称“实参”，可理解为调用方法时的真实条件
	--调用方法时argument列表要与定义方法时的parameter列表相匹配；   argument n.争论；论点；
		C#是强类型语言，argument是值、parameter是变量，值与变量一定要匹配，不然编译器会报错
	
构造器
*构造器（condtructor）是类型的成员之一  ctor+“tab”两次,自动构建一个代码片段
*狭义的构造器指的是“实例构造器”（instance constructor）
*如何调用构造器
*声明构造器
*构造器的内存原理

方法的重载（Overload）
*调用重载方式的示例
*声明带有重载的方法
	--方法签名（method signature）由方法的名称、类型形参的个数的它的每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。 方法签名不包含返回类型
	--实例构造函数签名有它的每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出 ）组成。
	--重载决策（到底调用哪一个重载）：用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。
	
如何对方法进行debug
*设置断点（breakpoint）
*观察方法电泳时的 call stack
*Step-in ,Step-over ,Step-out
*观察局部变量的值与变化

010-012 操作符详解
类型转换
*隐式（implicit）类似转换
	--不丢失精度的转换
	--子类向父类的转换		多态
	--装箱
*显式（explicit）类型转换
	--有可能丢失精度（甚至发生错误）的转换，即cast  。铸造
	--拆箱
	--使用Convert类
	--ToString方法与各数据的Parse /TryParse 方法
*自定义类型转换操作符
	--示例
	
	PositiveInfinity  正无穷大
	NegativeInfinity	负无穷大
	.GetType().FullName  数据类型

各类操作符示例。
	ildasm IL DASM 工具，查看低级语言代码，反汇编。
	
	
014、表达式，语句详解

语句的定义
*c#语言对语句的定义
	--c#语言的语句除了能够让程序员“顺序地”（sequentially）表达算法思想，还能通过条件判断、跳转和循环等方法控制程序逻辑的走向
	--简言之就是：陈述算法思想，控制逻辑走向，完成有意义的动作（action）;
	--c#语言的语句有分号（；）结尾，但有分号结尾的不一定都是语句；
	--语句一定是出现在方法体里

语句详解
statement
	labeled-statement 标签语句 
	declaration-statement
	embedded-statement
	
	数组的Array 类; IEnumerable 遍历接口;成员：GetEnumerator;配合while对集合进行遍历。
	foreach 语句，最好的用处就是对集合进行遍历。
	
0017 字段、属性、索引器、常量

字段
*什么是字段
	--字段（field）是一种表示与对象或类型（类与结构体）关联的变量
	--字段是类型的成员，旧称“成员变量”
	--与对象关联的字段亦称“实例字段”
	--与类型关联的字段称为“静态字段”，有static修饰
*字段的声明
	--参见C#语言定义文档
	--尽管字段声明带有分号，但它不是语句
	--字段的名字一定是名词
*字段的初始值
	--无显式初始化时，字段获得其类型的默认值，所以字段“永远都不会未被初始化”
	--实例字段初始化的时机————对象创建时
	--静态字段初始化的时机————类型被加载（load）时
*只读字段
	--实例只读字段
	--静态只读字段
	
属性
*什么是属性
	--属性（propety）是一种用于 访问对象或类型的特征的成员，特征反映了状态
	
	
C语言中的 struct


018、传值输出引用数组具名可选参数，扩展方法
传值参数
	*方法内局部变量，值参数创建变量的副本
	*对值参数的操作永远不影响变量的值
输出参数
应用参数
数组参数
	*必须是形参列表中的最后一个，由Params修饰
	*举例：String.Format 方法和String.Split方法
具名参数
	*参数的位置不再受约束
可选参数
	*参数因为具有默认值而变得“可选”
	*不推荐使用可选参数
扩展方法（this 参数）
	*方法必须是公有、静态的，即被Public static 所修饰
	*必须是形参列表中的第一个，由this修饰
	*必需由一个静态类（一般类名为SomeTypeExtension）来统一收纳对SomeType类型的扩展方法
	*举例：LINQ方法


019 委托详解
什么是委托
	*委托（delegate）是函数指针的“升级版”
		--实例：C/C++中的函数指针
	*一切皆地址
		--变量（数据）是以某个地址为起点的一段内存中所存储的值
		--函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令
	*直接调用与间接调用
		--直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回
		--间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在的地址并开始执行——返回
	*Java中没有与委托相对于的功能实体
	*委托的简单实用
		--Action委托	行动
		--Func委托  函数
	
	委托，是一种数据类型，是一种类	

委托的声明
	*委托是一个种类（class），类是数据类型所以委托也是一种数据类型
	*它的声明方式与一般的类不同，主要是为了照顾可读性和c/c++传统
	*注意声明委托的位置
		--避免写错地方结果声明成嵌套类型
	*委托与所封装的方法必需“类型兼容”
	
	delegate double Calc(double x, double y);
			double Add(double x,double y) 	{return x+y;}
			double Sub(double x,double y)	{return x-y;} 
			double Mul(double x,double y)	{retrun x*y;}
			double Div(double x,double y)	{return x/y;}
			
			返回值的数据类型一致
			参数列表在个数的数据类型上一致（参数名不需要一样）

委托的使用
*实例：把方法当作参数传递给另一个方法
	-正确使用1：模板方法，“借用”指定的外部方法来产生结果；
		--相当于“填空题”
		--常位与代码中部
		--委托有返回值
	-正确使用2：回调（callback）方法，调用指定的外部方法
		--相当于“流水线”
		--常位于代码末尾
		--委托无返回值
*注意：难精通+易使用+功能强大东西，一旦被滥用则后果非常严重
	-缺点1：这是一个方法级别的紧耦合，现实工作中要慎之又慎
	-确定2：使可读性下调、debug的难度增加
	-缺点3：把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护
	-缺点4：委托使用不当有可能造成内存泄漏和程序性能下降
	
	
020 事件详解
初步了解事件
*定义：单词Event,译为“事件”
	--《牛津词典》中的解释是“a thing that happens, especially somethiong important”
	--通顺的解释即使 “能够发生的什么事情”
*角色：使对象或类具备 通知能力 的成员
	--（中译）事件（event）是一种使对象或类能够提供通知的成员
	--（原文）An event is a member that enables an object or class to provide notifications.
	--"对象O拥有一个事件E"想表达的思想是：当事件E发生的时候，O有能力通过别的对象
*使用：用于对象的类间的动作协调与信息传递（消息推送）
*原理：事件模型（event model）中的两个”5
	--“发生>>响应”中的5个部分——闹钟响了你起床、孩子饿了你做饭...这里隐含着“订阅”关系
	--“发生>>响应”中的5个动作——
		1、我有一个事件。
		2、一个人或者一群人关心我的这个事件。
		3、我的这个事件发生了。
		4、关心这个事件的人会被依次通知到。
		5、被通知到的人根据拿到的事件信息（又称“事件数据”、“事件参数”、“通知“）对事件进行相应（又称”处理事件“）。
*提示
	--事件多用于桌面、手机等开发的客户端编程，因为这些程序经常是用于通过事件来“驱动”的
	--各种编程语言对这个机制的实现方法不尽相同
	--Java语言里没有事件这种成员，也没有委托这种数据类型。Java的"事件"是使用接口来实现的
	--MVC、MVP、MVVM 等模式，是事件模式更高级、更有效的“玩法”
	--日常开发的时候，使用已有事件的机会比较多，自己声明事件的机会比较少，所以先学使用
	
事件处理器 event handler	

五大数据类型：
*事件的订阅者
*事件消息的接收者
*事件的响应者
*事件的处理者
*被事件所通知的对象

事件信息
事件消息
事件数据
事件参数

事件的应用
*实例演示
	--派生（继承）与扩展（extends）
*事件模型的五个组成部分
	--1、事件的拥有者（event source ，对象）
	--2、事件成员（event ，成员）
	--3、事件的响应者（event subscriber ,对象）
	--4、事件处理器（event handler ,成员）——本质上是一个回调方法
	--5、事件订阅——把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”
*注意
	--事件处理器是方法成员
	--挂机额时间处理器的时候，可以使用委托实例，也可以直接使用方法名，这是合格“语法糖”
	--事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托类型来检测
	--事件可以同步调用也可以异步调用

深入理解事件

事件的声明
*事件的声明	
	--完整的声明
	--简略声明（字段式声明，field-like）
*有了委托字段/属性，为什么还需要事件？
	--为了程序的逻辑更加“有道理”、更加安全、谨防“借刀杀人”
*所以 事件的本质 是委托字段加一个包装器
	--这个包装器对委托字段的访问起 限制作用 ，相当于一个“蒙板”
	--封装（encapsulate）的一个重要功能就是隐藏
	--事件 对外界 隐藏了委托实例的大部分功能，仅暴露添加/移除事件处理器的功能
*用于声明事件的委托类型的命名约定
	--用于声明Foo事件的委托，一般命名为FooEventHandler(除非是一个非常通用的事件约束)
	--FooEventHandler委托的参数一般有两个（由Win32 API演化而来，历史悠久）
		---第一个是object类型，名字为sender,实际上就是事件的拥有者、事件的source
		---第二个是EventArgs类的派生类，类名一般为FooEventArgs,参数名为e。也就是前面讲过的事件参数
		---虽然没有官方的说法，但我们可以吧委托的参数列表看作是事件发生后发送给事件响应者的“事件消息”
	--触发Foo事件的方法一般命名为OnFoo,即“因何引发”、“事出有因”
		---访问几倍为protected,不能为public,不然又成了可以“借刀杀人”了
*事件的命名约定
	--带有时态的动词或者动词短语
	--事件拥有者“正在做”什么事情，用进行时；事件拥有者“做完了”什么事情，用完成时。


事件与委托的关系
*事件真的是“以特殊方式声明的委托字段/实例”吗？
	--不是！只是声明的时候“看的来像”（对比委托字段与事件的简化声明，field-like）
	--事件声明的时候使用了委托类型，简化声明造成事件看上去像一个委托的字段（实例），而event关键字则更像是一个修饰符
		————这就是错觉的来源之一
	--订阅事件的时候+=操作符后面可以是一个委托实例，者与委托实例的赋值方法语法相同，这也让事件看起来像是一个委托字段
		————这是错觉的又一个来源
	--重申：事件的本质是加装在委托字段上的一个“蒙板”（mask）,是个起掩蔽作用的包装器。这个用于阻挡非法操作的“蒙板”绝不是委托字段本身
*为什么要使用委托类型来声明事件？
	--站在source的角度来看，是为了表面source能对外传递哪些消息
	--站在subscriber的角度来看，它是一种约定，是为了约束能够使用什么样签名的方式来处理（响应）事件
	--委托类型的实例将用于存储（引用）事件处理器
*对比事件与属性
	--属性不是字段————很多时候属性是字段的包装器，这个包装器用来保护字段不被滥用
	--事件不是委托字段————它是委托字段的包装器，这个包装器用来保护委托字段不被滥用
	--包装器用于都不可能是被包装的东西
		
问题辨析


一个类里面包含了：
属性：存储数据
方法：做事情
事件：通知别人



特辑001
委托，Lambda,LINQ串讲
=================
什么是委托？
委托类型是怎么声明出来的？
泛型委托
我们必需自己创建委托类型吗？
泛型委托的类型参数推断
=================
方法与Lambda表达式之间的关系
如何把一个Lambda表达式赋值给一个委托类型参数
如何把一个Lambda表达式“喂”给一个委托类型参数
=================
LINQ


023 类
什么是“类”
	*是一种数据结构（data stucture）  抽象的数据结构
	*是一种数据类型
	*代表显示世界中的“种类”
构造器与析构器
	*实例
	*静态
类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和析构函数）以及嵌套类型。
类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专用化。 《C#语言规范》	

024 类的申明，继承和访问
*类申明的全貌
	--类声明的位置  ：名称空间（namespace)；声明在类体里面；所有的名称空间之外，YUAN全局名称空间。
	--声明即定义（C#与Java） 创建一个类，即声明，英文 Class declarations
		声明：
		定义：
*最简单的类声明
	--类的访问控制
*类成员的访问控制
*类的继承
	--派生类对基类的成员获得与访问
	--在派生类中访问基类的成员
	--构造器的不可继承性
	
*类的继承
	--类在功能上的扩展（extend）
	--只能有一个基类，但可以实现多个其接口
	--类访问级别对继承的影响
	--sealed类不能被继承
*成员的继承与访问
	--派生类对继承成员的访问
	--派生类对基类成员的访问
	--构造器的不可继承性
*面向对象的实现风格
	--Class-based			//.net 风格
	--Prototype-based 		//javascript 风格

Q:什么是继承呢？
A:继承就是子类在完整接收父类的成员的前提下，对于父类进行横向或纵向的扩展；横向扩展，是对类成员个数的扩充；纵向扩展，对类成员版本的更新，对类成员的重写。
	
026，重写与多态
*类的继承
	--类成员的“横向扩展”（成员越来越多）
	--类成员的“纵向扩展”（行为改变，版本增高）
	--类成员的隐藏（不常用）
	--重写与隐藏的发生条件：函数成员，可见，签名一致
*多态（polymorphism）
	--基于重写机制（virtual>override）	//重写
	--函数成员的基于行为（版本）有对象决定
	--回顾：C#语言的变量和对象都是有类型的，所以会有“代差”
	
027 抽象类与开闭原则
*什么是接口和抽象类
	--接口和抽象类都是“软件工程产物”
	--具体类 →抽象类 →接口：越来越抽象，内部实现的东西越来越少
	--抽象类是未完全实现逻辑的类（可以有字段和非public成员，他们代表了“具体逻辑”）
	--抽象类为复用而生：专门作为基类来使用，也具有解耦功能
	--封装确定的，开放不确定的，推迟到合适的子类中去实现
	--接口是完全未实现逻辑的“类”（“纯虚类”；只有函数成员；成员全部public）
	--接口为解耦而生："高内聚，低耦合"，方便单元测试
	--接口是一个“协约”，早已为工业生产所熟悉（有分工必有协作，有协作必有协约）
	--它们都不能实例化，只能用来声明变量、引用具体类（concrete class）的实例
	
		abstract 抽象的，没有方法体了，用
		override 重写
		virtual 虚拟的
		interface 接口
028 接口与单元测试
	--接口的产生：自底向上（重构），自顶向下（设计）
	--C#中接口的实现（隐式，显式，多接口）
	--语言对面向对象设计的内建支持：依赖反转，接口隔离，开/闭原则。。。。。

	
	
	检测项目：
1、外壳阻燃; GB/T 4793
2、标记说明;
3、噪声＜45dB;
4、性能指标
1)	设备参数为8通道;
2)	工作行程400mm×250mm×200mm;
3)	重复定位精度±0.01mm，分辨精度±0.5μm;
4)	打印温区-20℃-260℃;
5)	兼容熔融沉积、光固化和微滴喷射3种原理打印喷头;
6)	设备集成光学在线检测系统和生物反应器，分辨率优于 20μm 。


	